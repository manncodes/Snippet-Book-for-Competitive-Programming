{
	"PermToInt": {
		"prefix": "permuta",
		"body": [
		  "/**",
		  " * Description: Permutation -> integer conversion. (Not order preserving.)",
		  " * Integer -> permutation can use a lookup table.",
		  " * Time: O(n)",
		  " */",
		  "",
		  "",
		  "int permToInt(vi& v) {",
		  "	int use = 0, i = 0, r = 0;",
		  "	for(int x:v) r = r * ++i + __builtin_popcount(use & -(1<<x)),",
		  "		use |= 1 << x;                     // (note: minus, not ~!)",
		  "	return r;",
		  "}",
		  ""
		],
		"description": "PermToInt"
	  },

	"Mutinomial": {
		"prefix": "multinomial",
		"body": [
		  "/**",
		  " * Description: Computes $\\displaystyle \\binom{k_1 + \\dots + k_n}{k_1, k_2, \\dots, k_n} = \\frac{(\\sum k_i)!}{k_1!k_2!...k_n!}$.",
		  " * Status: Tested on kattis:lexicography",
		  " */",
		  "",
		  "ll multinomial(vi& v) {",
		  "	ll c = 1, m = v.empty() ? 1 : v[0];",
		  "	rep(i,1,sz(v)) rep(j,0,v[i])",
		  "		c = c * ++m / (j+1);",
		  "	return c;",
		  "}",
		  ""
		],
		"description": "Mutinomial"
	  },

	"FenwickTree": {
		"prefix": "fenwick tree",
		"body": [
		  "/**",
		  " * Description: Computes partial sums a[0] + a[1] + ... + a[pos - 1], and updates single elements a[i],",
		  " * taking the difference between the old and new value.",
		  " * Time: Both operations are $O(\\log N)$.",
		  " * Status: Stress-tested",
		  " */",
		  "#pragma once",
		  "",
		  "struct FT {",
		  "	vector<ll> s;",
		  "	FT(int n) : s(n) {}",
		  "	void update(int pos, ll dif) { // a[pos] += dif",
		  "		for (; pos < sz(s); pos |= pos + 1) s[pos] += dif;",
		  "	}",
		  "	ll query(int pos) { // sum of values in [0, pos)",
		  "		ll res = 0;",
		  "		for (; pos > 0; pos &= pos - 1) res += s[pos-1];",
		  "		return res;",
		  "	}",
		  "	int lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum",
		  "		// Returns n if no sum is >= sum, or -1 if empty sum is.",
		  "		if (sum <= 0) return -1;",
		  "		int pos = 0;",
		  "		for (int pw = 1 << 25; pw; pw >>= 1) {",
		  "			if (pos + pw <= sz(s) && s[pos + pw-1] < sum)",
		  "				pos += pw, sum -= s[pos-1];",
		  "		}",
		  "		return pos;",
		  "	}",
		  "};",
		  ""
		],
		"description": "FenwickTree"
	  },
	
	  "FenwickTree2D": {
		"prefix": "fenwick tree 2D",
		"body": [
		  "/**",
		  " * Description: Computes sums a[i,j] for all i<I, j<J, and increases single elements a[i,j].",
		  " *  Requires that the elements to be updated are known in advance (call fakeUpdate() before init()).",
		  " * Time: $O(\\log^2 N)$. (Use persistent segment trees for $O(\\log N)$.)",
		  " * Status: stress-tested",
		  " */",
		  "struct FT {",
		  "	vector<ll> s;",
		  "	FT(int n) : s(n) {}",
		  "	void update(int pos, ll dif) { // a[pos] += dif",
		  "		for (; pos < sz(s); pos |= pos + 1) s[pos] += dif;",
		  "	}",
		  "	ll query(int pos) { // sum of values in [0, pos)",
		  "		ll res = 0;",
		  "		for (; pos > 0; pos &= pos - 1) res += s[pos-1];",
		  "		return res;",
		  "	}",
		  "	int lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum",
		  "		// Returns n if no sum is >= sum, or -1 if empty sum is.",
		  "		if (sum <= 0) return -1;",
		  "		int pos = 0;",
		  "		for (int pw = 1 << 25; pw; pw >>= 1) {",
		  "			if (pos + pw <= sz(s) && s[pos + pw-1] < sum)",
		  "				pos += pw, sum -= s[pos-1];",
		  "		}",
		  "		return pos;",
		  "	}",
		  "};",
		  "",
		  "",
		  "struct FT2 {",
		  "	vector<vi> ys; vector<FT> ft;",
		  "	FT2(int limx) : ys(limx) {}",
		  "	void fakeUpdate(int x, int y) {",
		  "		for (; x < sz(ys); x |= x + 1) ys[x].push_back(y);",
		  "	}",
		  "	void init() {",
		  "		for (vi& v : ys) sort(all(v)), ft.emplace_back(sz(v));",
		  "	}",
		  "	int ind(int x, int y) {",
		  "		return (int)(lower_bound(all(ys[x]), y) - ys[x].begin()); }",
		  "	void update(int x, int y, ll dif) {",
		  "		for (; x < sz(ys); x |= x + 1)",
		  "			ft[x].update(ind(x, y), dif);",
		  "	}",
		  "	ll query(int x, int y) {",
		  "		ll sum = 0;",
		  "		for (; x; x &= x - 1)",
		  "			sum += ft[x-1].query(ind(x-1, y));",
		  "		return sum;",
		  "	}",
		  "};",
		  ""
		],
		"description": "FenwickTree2D"
	  },
	
	  "HashMap": {
		"prefix": "hashmap",
		"body": [
		  "/**",
		  " * Source: http://codeforces.com/blog/entry/60737",
		  " * Description: Hash map with mostly the same API as unordered\\_map, but \\tilde",
		  " * 3x faster. Uses 1.5x memory.",
		  " * Initial capacity must be a power of 2 (if provided).",
		  " */",
		  "#pragma once",
		  "",
		  "#include <bits/extc++.h> /** keep-include */",
		  "// To use most bits rather than just the lowest ones:",
		  "struct chash { // large odd number for C",
		  "	const uint64_t C = ll(4e18 * acos(0)) | 71;",
		  "	ll operator()(ll x) const { return __builtin_bswap64(x*C); }",
		  "};",
		  "__gnu_pbds::gp_hash_table<ll,int,chash> h({},{},{},{},{1<<16});",
		  "",
		  "/** For CodeForces, or other places where hacking might be a problem:",
		  "",
		  "const int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();",
		  "struct chash { // To use most bits rather than just the lowest ones:",
		  "	const uint64_t C = ll(4e18 * acos(0)) | 71; // large odd number",
		  "	ll operator()(ll x) const { return __builtin_bswap64((x^RANDOM)*C); }",
		  "};",
		  "__gnu_pbds::gp_hash_table<ll, int, chash> h({},{},{},{}, {1 << 16});",
		  "*/",
		  ""
		],
		"description": "HashMap"
	  },

	  "Lazy Segment Tree": {
		"prefix": "lazy segment tree",
		"body": [
		  "/**",
		  " * Description: Segment tree with ability to add or set values of large intervals, and compute max of intervals.",
		  " * Can be changed to other things.",
		  " * Use with a bump allocator for better performance, and SmallPtr or implicit indices to save memory.",
		  " * Time: O(\\log N).",
		  " * Usage: Node* tr = new Node(v, 0, sz(v));",
		  " * Status: stress-tested a bit",
		  " */",
		  "#pragma once",
		  "",
		  "",
		  "// Either globally or in a single class:",
		  "static char buf[450 << 20];",
		  "void* operator new(size_t s) {",
		  "	static size_t i = sizeof buf;",
		  "	assert(s < i);",
		  "	return (void*)&buf[i -= s];",
		  "}",
		  "void operator delete(void*) {}",
		  "",
		  "",
		  "const int inf = 1e9;",
		  "struct Node {",
		  "	Node *l = 0, *r = 0;",
		  "	int lo, hi, mset = inf, madd = 0, val = -inf;",
		  "	Node(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf",
		  "	Node(vi& v, int lo, int hi) : lo(lo), hi(hi) {",
		  "		if (lo + 1 < hi) {",
		  "			int mid = lo + (hi - lo)/2;",
		  "			l = new Node(v, lo, mid); r = new Node(v, mid, hi);",
		  "			val = max(l->val, r->val);",
		  "		}",
		  "		else val = v[lo];",
		  "	}",
		  "	int query(int L, int R) {",
		  "		if (R <= lo || hi <= L) return -inf;",
		  "		if (L <= lo && hi <= R) return val;",
		  "		push();",
		  "		return max(l->query(L, R), r->query(L, R));",
		  "	}",
		  "	void set(int L, int R, int x) {",
		  "		if (R <= lo || hi <= L) return;",
		  "		if (L <= lo && hi <= R) mset = val = x, madd = 0;",
		  "		else {",
		  "			push(), l->set(L, R, x), r->set(L, R, x);",
		  "			val = max(l->val, r->val);",
		  "		}",
		  "	}",
		  "	void add(int L, int R, int x) {",
		  "		if (R <= lo || hi <= L) return;",
		  "		if (L <= lo && hi <= R) {",
		  "			if (mset != inf) mset += x;",
		  "			else madd += x;",
		  "			val += x;",
		  "		}",
		  "		else {",
		  "			push(), l->add(L, R, x), r->add(L, R, x);",
		  "			val = max(l->val, r->val);",
		  "		}",
		  "	}",
		  "	void push() {",
		  "		if (!l) {",
		  "			int mid = lo + (hi - lo)/2;",
		  "			l = new Node(lo, mid); r = new Node(mid, hi);",
		  "		}",
		  "		if (mset != inf)",
		  "			l->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;",
		  "		else if (madd)",
		  "			l->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;",
		  "	}",
		  "};",
		  ""
		],
		"description": "Lazy Segment Tree"
	  },
	  "Line Container": {
		"prefix": "Line Container",
		"body": [
		  "/**",
		  " * Description: Container where you can add lines of the form kx+m, and query maximum values at points x.",
		  " *  Useful for dynamic programming (``convex hull trick'').",
		  " * Time: O(\\log N)",
		  " * Status: stress-tested",
		  " */",
		  "#pragma once",
		  "",
		  "struct Line {",
		  "	mutable ll k, m, p;",
		  "	bool operator<(const Line& o) const { return k < o.k; }",
		  "	bool operator<(ll x) const { return p < x; }",
		  "};",
		  "",
		  "struct LineContainer : multiset<Line, less<>> {",
		  "	// (for doubles, use inf = 1/.0, div(a,b) = a/b)",
		  "	static const ll inf = LLONG_MAX;",
		  "	ll div(ll a, ll b) { // floored division",
		  "		return a / b - ((a ^ b) < 0 && a % b); }",
		  "	bool isect(iterator x, iterator y) {",
		  "		if (y == end()) { x->p = inf; return false; }",
		  "		if (x->k == y->k) x->p = x->m > y->m ? inf : -inf;",
		  "		else x->p = div(y->m - x->m, x->k - y->k);",
		  "		return x->p >= y->p;",
		  "	}",
		  "	void add(ll k, ll m) {",
		  "		auto z = insert({k, m, 0}), y = z++, x = y;",
		  "		while (isect(y, z)) z = erase(z);",
		  "		if (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
		  "		while ((y = x) != begin() && (--x)->p >= y->p)",
		  "			isect(x, erase(y));",
		  "	}",
		  "	ll query(ll x) {",
		  "		assert(!empty());",
		  "		auto l = *lower_bound(x);",
		  "		return l.k * x + l.m;",
		  "	}",
		  "};",
		  ""
		],
		"description": "Line Container"
	  },
	  "matrix": {
		"prefix": "matrix",
		"body": [
		  "/**",
		  " * Description: Basic operations on square matrices.",
		  " * Usage: Matrix<int, 3> A;",
		  " *  A.d = {{{{1,2,3}}, {{4,5,6}}, {{7,8,9}}}};",
		  " *  vector<int> vec = {1,2,3};",
		  " *  vec = (A^N) * vec;",
		  " * Status: tested",
		  " */",
		  "#pragma once",
		  "",
		  "template<class T, int N> struct Matrix {",
		  "	typedef Matrix M;",
		  "	array<array<T, N>, N> d{};",
		  "	M operator*(const M& m) const {",
		  "		M a;",
		  "		rep(i,0,N) rep(j,0,N)",
		  "			rep(k,0,N) a.d[i][j] += d[i][k]*m.d[k][j];",
		  "		return a;",
		  "	}",
		  "	vector<T> operator*(const vector<T>& vec) const {",
		  "		vector<T> ret(N);",
		  "		rep(i,0,N) rep(j,0,N) ret[i] += d[i][j] * vec[j];",
		  "		return ret;",
		  "	}",
		  "	M operator^(ll p) const {",
		  "		assert(p >= 0);",
		  "		M a, b(*this);",
		  "		rep(i,0,N) a.d[i][i] = 1;",
		  "		while (p) {",
		  "			if (p&1) a = a*b;",
		  "			b = b*b;",
		  "			p >>= 1;",
		  "		}",
		  "		return a;",
		  "	}",
		  "};",
		  ""
		],
		"description": "matrix"
	  },
	  "Order Statistic Tree": {
		"prefix": "order statistic tree",
		"body": [
		  "/**",
		  " * Description: A set (not multiset!) with support for finding the n'th",
		  " * element, and finding the index of an element.",
		  " * To get a map, change \\texttt{null\\_type}.",
		  " * Time: O(\\log N)",
		  " */",
		  "#pragma once",
		  "",
		  "#include <bits/extc++.h> /** keep-include */",
		  "using namespace __gnu_pbds;",
		  "",
		  "template<class T>",
		  "using Tree = tree<T, null_type, less<T>, rb_tree_tag,",
		  "    tree_order_statistics_node_update>;",
		  "",
		  "void example() {",
		  "	Tree<int> t, t2; t.insert(8);",
		  "	auto it = t.insert(10).first;",
		  "	assert(it == t.lower_bound(9));",
		  "	assert(t.order_of_key(10) == 1);",
		  "	assert(t.order_of_key(11) == 2);",
		  "	assert(*t.find_by_order(0) == 8);",
		  "	t.join(t2); // assuming T < T2 or T > T2, merge t2 into t",
		  "}",
		  ""
		],
		"description": "Order Statistic Tree"
	  },
	  "RMQ": {
		"prefix": "rmq",
		"body": [
		  "/**",
		  " * Description: Range Minimum Queries on an array. Returns",
		  " * min(V[a], V[a + 1], ... V[b - 1]) in constant time.",
		  " * Usage:",
		  " *  RMQ rmq(values);",
		  " *  rmq.query(inclusive, exclusive);",
		  " * Time: $O(|V| \\log |V| + Q)$",
		  " * Status: stress-tested",
		  " */",
		  "#pragma once",
		  "",
		  "template<class T>",
		  "struct RMQ {",
		  "	vector<vector<T>> jmp;",
		  "	RMQ(const vector<T>& V) : jmp(1, V) {",
		  "		for (int pw = 1, k = 1; pw * 2 <= sz(V); pw *= 2, ++k) {",
		  "			jmp.emplace_back(sz(V) - pw * 2 + 1);",
		  "			rep(j,0,sz(jmp[k]))",
		  "				jmp[k][j] = min(jmp[k - 1][j], jmp[k - 1][j + pw]);",
		  "		}",
		  "	}",
		  "	T query(int a, int b) {",
		  "		assert(a < b); // or return inf if a == b",
		  "		int dep = 31 - __builtin_clz(b - a);",
		  "		return min(jmp[dep][a], jmp[dep][b - (1 << dep)]);",
		  "	}",
		  "};",
		  ""
		],
		"description": "RMQ"
	  },
	  "Segment Tree": {
		"prefix": "segment tree",
		"body": [
		  "/**",
		  " * Description: Zero-indexed max-tree. Bounds are inclusive to the left and exclusive to the right. Can be changed by modifying T, f and unit.",
		  " * Time: O(\\log N)",
		  " * Status: stress-tested",
		  " */",
		  "#pragma once",
		  "",
		  "struct Tree {",
		  "	typedef int T;",
		  "	static constexpr T unit = INT_MIN;",
		  "	T f(T a, T b) { return max(a, b); } // (any associative fn)",
		  "	vector<T> s; int n;",
		  "	Tree(int n = 0, T def = unit) : s(2*n, def), n(n) {}",
		  "	void update(int pos, T val) {",
		  "		for (s[pos += n] = val; pos /= 2;)",
		  "			s[pos] = f(s[pos * 2], s[pos * 2 + 1]);",
		  "	}",
		  "	T query(int b, int e) { // query [b, e)",
		  "		T ra = unit, rb = unit;",
		  "		for (b += n, e += n; b < e; b /= 2, e /= 2) {",
		  "			if (b % 2) ra = f(ra, s[b++]);",
		  "			if (e % 2) rb = f(s[--e], rb);",
		  "		}",
		  "		return f(ra, rb);",
		  "	}",
		  "};",
		  ""
		],
		"description": "Segment Tree"
	  },
	  "Submatrix": {
		"prefix": "submatrix",
		"body": [
		  "/**",
		  " * Description: Calculate submatrix sums quickly, given upper-left and lower-right corners (half-open).",
		  " * Usage:",
		  " * SubMatrix<int> m(matrix);",
		  " * m.sum(0, 0, 2, 2); // top left 4 elements",
		  " * Time: O(N^2 + Q)",
		  " */",
		  "#pragma once",
		  "",
		  "template<class T>",
		  "struct SubMatrix {",
		  "	vector<vector<T>> p;",
		  "	SubMatrix(vector<vector<T>>& v) {",
		  "		int R = sz(v), C = sz(v[0]);",
		  "		p.assign(R+1, vector<T>(C+1));",
		  "		rep(r,0,R) rep(c,0,C)",
		  "			p[r+1][c+1] = v[r][c] + p[r][c+1] + p[r+1][c] - p[r][c];",
		  "	}",
		  "	T sum(int u, int l, int d, int r) {",
		  "		return p[d][r] - p[d][l] - p[u][r] + p[u][l];",
		  "	}",
		  "};",
		  ""
		],
		"description": "Submatrix"
	  },
	  "Treap": {
		"prefix": "treap",
		"body": [
		  "/**",
		  " * Description: A short self-balancing tree. It acts as a",
		  " *  sequential container with log-time splits/joins, and",
		  " *  is easy to augment with additional data.",
		  " * Time: $O(\\log N)$",
		  " * Status: stress-tested",
		  " */",
		  "#pragma once",
		  "",
		  "struct Node {",
		  "	Node *l = 0, *r = 0;",
		  "	int val, y, c = 1;",
		  "	Node(int val) : val(val), y(rand()) {}",
		  "	void recalc();",
		  "};",
		  "",
		  "int cnt(Node* n) { return n ? n->c : 0; }",
		  "void Node::recalc() { c = cnt(l) + cnt(r) + 1; }",
		  "",
		  "template<class F> void each(Node* n, F f) {",
		  "	if (n) { each(n->l, f); f(n->val); each(n->r, f); }",
		  "}",
		  "",
		  "pair<Node*, Node*> split(Node* n, int k) {",
		  "	if (!n) return {};",
		  "	if (cnt(n->l) >= k) { // \"n->val >= k\" for lower_bound(k)",
		  "		auto pa = split(n->l, k);",
		  "		n->l = pa.second;",
		  "		n->recalc();",
		  "		return {pa.first, n};",
		  "	} else {",
		  "		auto pa = split(n->r, k - cnt(n->l) - 1); // and just \"k\"",
		  "		n->r = pa.first;",
		  "		n->recalc();",
		  "		return {n, pa.second};",
		  "	}",
		  "}",
		  "",
		  "Node* merge(Node* l, Node* r) {",
		  "	if (!l) return r;",
		  "	if (!r) return l;",
		  "	if (l->y > r->y) {",
		  "		l->r = merge(l->r, r);",
		  "		l->recalc();",
		  "		return l;",
		  "	} else {",
		  "		r->l = merge(l, r->l);",
		  "		r->recalc();",
		  "		return r;",
		  "	}",
		  "}",
		  "",
		  "Node* ins(Node* t, Node* n, int pos) {",
		  "	auto pa = split(t, pos);",
		  "	return merge(merge(pa.first, n), pa.second);",
		  "}",
		  "",
		  "// Example application: move the range [l, r) to index k",
		  "void move(Node*& t, int l, int r, int k) {",
		  "	Node *a, *b, *c;",
		  "	tie(a,b) = split(t, l); tie(b,c) = split(b, r - l);",
		  "	if (k <= l) t = merge(ins(a, b, k), c);",
		  "	else t = merge(a, ins(c, b, k - r));",
		  "}",
		  ""
		],
		"description": "Treap"
	  },
	  "Union Find ": {
		"prefix": "union find",
		"body": [
		  "/**",
		  " * Description: Disjoint-set data structure.",
		  " * Time: $O(\\alpha(N))$",
		  " */",
		  "#pragma once",
		  "",
		  "struct UF {",
		  "	vi e;",
		  "	UF(int n) : e(n, -1) {}",
		  "	bool sameSet(int a, int b) { return find(a) == find(b); }",
		  "	int size(int x) { return -e[find(x)]; }",
		  "	int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }",
		  "	bool join(int a, int b) {",
		  "		a = find(a), b = find(b);",
		  "		if (a == b) return false;",
		  "		if (e[a] > e[b]) swap(a, b);",
		  "		e[a] += e[b]; e[b] = a;",
		  "		return true;",
		  "	}",
		  "};",
		  ""
		],
		"description": "Union Find "
	  },
	  "2SAT": {
		"prefix": "2sat",
		"body": [
		  "/**",
		  " * Description: Calculates a valid assignment to boolean variables a, b, c,... to a 2-SAT problem, so that an expression of the type $(a\\|\\|b)\\&\\&(!a\\|\\|c)\\&\\&(d\\|\\|!b)\\&\\&...$ becomes true, or reports that it is unsatisfiable.",
		  " * Negated variables are represented by bit-inversions (\\texttt{\\tilde{}x}).",
		  " * Usage:",
		  " *  TwoSat ts(number of boolean variables);",
		  " *  ts.either(0, \\tilde3); // Var 0 is true or var 3 is false",
		  " *  ts.setValue(2); // Var 2 is true",
		  " *  ts.atMostOne({0,\\tilde1,2}); // <= 1 of vars 0, \\tilde1 and 2 are true",
		  " *  ts.solve(); // Returns true iff it is solvable",
		  " *  ts.values[0..N-1] holds the assigned values to the vars",
		  " * Time: O(N+E), where N is the number of boolean variables, and E is the number of clauses.",
		  " * Status: stress-tested",
		  " */",
		  "#pragma once",
		  "",
		  "struct TwoSat {",
		  "	int N;",
		  "	vector<vi> gr;",
		  "	vi values; // 0 = false, 1 = true",
		  "",
		  "	TwoSat(int n = 0) : N(n), gr(2*n) {}",
		  "",
		  "	int addVar() { // (optional)",
		  "		gr.emplace_back();",
		  "		gr.emplace_back();",
		  "		return N++;",
		  "	}",
		  "",
		  "	void either(int f, int j) {",
		  "		f = max(2*f, -1-2*f);",
		  "		j = max(2*j, -1-2*j);",
		  "		gr[f].push_back(j^1);",
		  "		gr[j].push_back(f^1);",
		  "	}",
		  "	void setValue(int x) { either(x, x); }",
		  "",
		  "	void atMostOne(const vi& li) { // (optional)",
		  "		if (sz(li) <= 1) return;",
		  "		int cur = ~li[0];",
		  "		rep(i,2,sz(li)) {",
		  "			int next = addVar();",
		  "			either(cur, ~li[i]);",
		  "			either(cur, next);",
		  "			either(~li[i], next);",
		  "			cur = ~next;",
		  "		}",
		  "		either(cur, ~li[1]);",
		  "	}",
		  "",
		  "	vi val, comp, z; int time = 0;",
		  "	int dfs(int i) {",
		  "		int low = val[i] = ++time, x; z.push_back(i);",
		  "		for(int e : gr[i]) if (!comp[e])",
		  "			low = min(low, val[e] ?: dfs(e));",
		  "		if (low == val[i]) do {",
		  "			x = z.back(); z.pop_back();",
		  "			comp[x] = low;",
		  "			if (values[x>>1] == -1)",
		  "				values[x>>1] = x&1;",
		  "		} while (x != i);",
		  "		return val[i] = low;",
		  "	}",
		  "",
		  "	bool solve() {",
		  "		values.assign(N, -1);",
		  "		val.assign(2*N, 0); comp = val;",
		  "		rep(i,0,2*N) if (!comp[i]) dfs(i);",
		  "		rep(i,0,N) if (comp[2*i] == comp[2*i+1]) return 0;",
		  "		return 1;",
		  "	}",
		  "};",
		  ""
		],
		"description": "2SAT"
	  },
	  "Bellman Ford": {
		"prefix": "bellman ford",
		"body": [
		  "/**",
		  " * Source: http://en.wikipedia.org/wiki/Bellman-Ford_algorithm",
		  " * Description: Calculates shortest paths from $s$ in a graph that might have negative edge weights.",
		  " * Unreachable nodes get dist = inf; nodes reachable through negative-weight cycles get dist = -inf.",
		  " * Assumes $V^2 \\max |w_i| < \\tilde{} 2^{63}$.",
		  " * Time: O(VE)",
		  " * Status: Tested on kattis:shortestpath3",
		  " */",
		  "#pragma once",
		  "",
		  "const ll inf = LLONG_MAX;",
		  "struct Ed { int a, b, w, s() { return a < b ? a : -a; }};",
		  "struct Node { ll dist = inf; int prev = -1; };",
		  "",
		  "void bellmanFord(vector<Node>& nodes, vector<Ed>& eds, int s) {",
		  "	nodes[s].dist = 0;",
		  "	sort(all(eds), [](Ed a, Ed b) { return a.s() < b.s(); });",
		  "",
		  "	int lim = sz(nodes) / 2 + 2; // /3+100 with shuffled vertices",
		  "	rep(i,0,lim) for (Ed ed : eds) {",
		  "		Node cur = nodes[ed.a], &dest = nodes[ed.b];",
		  "		if (abs(cur.dist) == inf) continue;",
		  "		ll d = cur.dist + ed.w;",
		  "		if (d < dest.dist) {",
		  "			dest.prev = ed.a;",
		  "			dest.dist = (i < lim-1 ? d : -inf);",
		  "		}",
		  "	}",
		  "	rep(i,0,lim) for (Ed e : eds) {",
		  "		if (nodes[e.a].dist == -inf)",
		  "			nodes[e.b].dist = -inf;",
		  "	}",
		  "}",
		  ""
		],
		"description": "Bellman Ford"
	  },
	  "Biconnnected Components": {
		"prefix": "binconnected components",
		"body": [
		  "/**",
		  " * Description: Finds all biconnected components in an undirected graph, and",
		  " *  runs a callback for the edges in each. In a biconnected component there",
		  " *  are at least two distinct paths between any two nodes. Note that a node can",
		  " *  be in several components. An edge which is not in a component is a bridge,",
		  " *  i.e., not part of any cycle.",
		  " * Time: O(E + V)",
		  " * Status: tested during MIPT ICPC Workshop 2017",
		  " * Usage:",
		  " *  int eid = 0; ed.resize(N);",
		  " *  for each edge (a,b) {",
		  " *    ed[a].emplace_back(b, eid);",
		  " *    ed[b].emplace_back(a, eid++); }",
		  " *  bicomps([\\&](const vi\\& edgelist) {...});",
		  " */",
		  "#pragma once",
		  "",
		  "vi num, st;",
		  "vector<vector<pii>> ed;",
		  "int Time;",
		  "template<class F>",
		  "int dfs(int at, int par, F& f) {",
		  "	int me = num[at] = ++Time, e, y, top = me;",
		  "	for (auto pa : ed[at]) if (pa.second != par) {",
		  "		tie(y, e) = pa;",
		  "		if (num[y]) {",
		  "			top = min(top, num[y]);",
		  "			if (num[y] < me)",
		  "				st.push_back(e);",
		  "		} else {",
		  "			int si = sz(st);",
		  "			int up = dfs(y, e, f);",
		  "			top = min(top, up);",
		  "			if (up == me) {",
		  "				st.push_back(e);",
		  "				f(vi(st.begin() + si, st.end()));",
		  "				st.resize(si);",
		  "			}",
		  "			else if (up < me) st.push_back(e);",
		  "			else { /* e is a bridge */ }",
		  "		}",
		  "	}",
		  "	return top;",
		  "}",
		  "",
		  "template<class F>",
		  "void bicomps(F f) {",
		  "	num.assign(sz(ed), 0);",
		  "	rep(i,0,sz(ed)) if (!num[i]) dfs(i, -1, f);",
		  "}",
		  ""
		],
		"description": "Biconnnected Components"
	  },
	  "Binary Lifting": {
		"prefix": "binary lifting",
		"body": [
		  "/**",
		  " * Description: Calculate power of two jumps in a tree,",
		  " * to support fast upward jumps and LCAs.",
		  " * Assumes the root node points to itself.",
		  " * Time: construction $O(N \\log N)$, queries $O(\\log N)$",
		  " * Status: Tested at Petrozavodsk, also stress-tested via LCA.cpp",
		  " */",
		  "#pragma once",
		  "",
		  "vector<vi> treeJump(vi& P){",
		  "	int on = 1, d = 1;",
		  "	while(on < sz(P)) on *= 2, d++;",
		  "	vector<vi> jmp(d, P);",
		  "	rep(i,1,d) rep(j,0,sz(P))",
		  "		jmp[i][j] = jmp[i-1][jmp[i-1][j]];",
		  "	return jmp;",
		  "}",
		  "",
		  "int jmp(vector<vi>& tbl, int nod, int steps){",
		  "	rep(i,0,sz(tbl))",
		  "		if(steps&(1<<i)) nod = tbl[i][nod];",
		  "	return nod;",
		  "}",
		  "",
		  "int lca(vector<vi>& tbl, vi& depth, int a, int b) {",
		  "	if (depth[a] < depth[b]) swap(a, b);",
		  "	a = jmp(tbl, a, depth[a] - depth[b]);",
		  "	if (a == b) return a;",
		  "	for (int i = sz(tbl); i--;) {",
		  "		int c = tbl[i][a], d = tbl[i][b];",
		  "		if (c != d) a = c, b = d;",
		  "	}",
		  "	return tbl[0][a];",
		  "}",
		  ""
		],
		"description": "Binary Lifting"
	  },
	  "Directed MST": {
		"prefix": "directed MST",
		"body": [
		  "/**",
		  " * Description: Edmonds' algorithm for finding the weight of the minimum spanning",
		  " * tree/arborescence of a directed graph, given a root node. If no MST exists, returns -1.",
		  " * Time: O(E \\log V)",
		  " * Status: Stress-tested, also tested on NWERC 2018 fastestspeedrun",
		  " */",
		  "#pragma once",
		  "",
		  "// #include \"../data-structures/UnionFind.h\"",
		  "",
		  "struct Edge { int a, b; ll w; };",
		  "struct Node { /// lazy skew heap node",
		  "	Edge key;",
		  "	Node *l, *r;",
		  "	ll delta;",
		  "	void prop() {",
		  "		key.w += delta;",
		  "		if (l) l->delta += delta;",
		  "		if (r) r->delta += delta;",
		  "		delta = 0;",
		  "	}",
		  "	Edge top() { prop(); return key; }",
		  "};",
		  "Node *merge(Node *a, Node *b) {",
		  "	if (!a || !b) return a ?: b;",
		  "	a->prop(), b->prop();",
		  "	if (a->key.w > b->key.w) swap(a, b);",
		  "	swap(a->l, (a->r = merge(b, a->r)));",
		  "	return a;",
		  "}",
		  "void pop(Node*& a) { a->prop(); a = merge(a->l, a->r); }",
		  "",
		  "ll dmst(int n, int r, vector<Edge>& g) {",
		  "	UF uf(n);",
		  "	vector<Node*> heap(n);",
		  "	for (Edge e : g) heap[e.b] = merge(heap[e.b], new Node{e});",
		  "	ll res = 0;",
		  "	vi seen(n, -1), path(n);",
		  "	seen[r] = r;",
		  "	rep(s,0,n) {",
		  "		int u = s, qi = 0, w;",
		  "		while (seen[u] < 0) {",
		  "			path[qi++] = u, seen[u] = s;",
		  "			if (!heap[u]) return -1;",
		  "			Edge e = heap[u]->top();",
		  "			heap[u]->delta -= e.w, pop(heap[u]);",
		  "			res += e.w, u = uf.find(e.a);",
		  "			if (seen[u] == s) {",
		  "				Node* cyc = 0;",
		  "				do cyc = merge(cyc, heap[w = path[--qi]]);",
		  "				while (uf.join(u, w));",
		  "				u = uf.find(u);",
		  "				heap[u] = cyc, seen[u] = -1;",
		  "			}",
		  "		}",
		  "	}",
		  "	return res;",
		  "}",
		  ""
		],
		"description": "Directed MST"
	  },
	  "LCA": {
		"prefix": "lca",
		"body": [
		  "/**",
		  " * Description: Data structure for computing lowest common ancestors in a tree",
		  " * (with 0 as root). C should be an adjacency list of the tree, either directed",
		  " * or undirected.",
		  " * Time: $O(N \\log N + Q)$",
		  " * Status: stress-tested",
		  " */",
		  "#pragma once",
		  "",
		  "// #include \"../data-structures/RMQ.h\"",
		  "",
		  "struct LCA {",
		  "	int T = 0;",
		  "	vi time, path, ret;",
		  "	RMQ<int> rmq;",
		  "",
		  "	LCA(vector<vi>& C) : time(sz(C)), rmq((dfs(C,0,-1), ret)) {}",
		  "	void dfs(vector<vi>& C, int v, int par) {",
		  "		time[v] = T++;",
		  "		for (int y : C[v]) if (y != par) {",
		  "			path.push_back(v), ret.push_back(time[v]);",
		  "			dfs(C, y, v);",
		  "		}",
		  "	}",
		  "",
		  "	int lca(int a, int b) {",
		  "		if (a == b) return a;",
		  "		tie(a, b) = minmax(time[a], time[b]);",
		  "		return path[rmq.query(a, b)];",
		  "	}",
		  "	//dist(a,b){return depth[a] + depth[b] - 2*depth[lca(a,b)];}",
		  "};",
		  ""
		],
		"description": "LCA"
	  },
	  "DFS Matching": {
		"prefix": "dfs matching",
		"body": [
		  "/**",
		  " * Description: Simple bipartite matching algorithm. Graph $g$ should be a list",
		  " * of neighbors of the left partition, and $btoa$ should be a vector full of",
		  " * -1's of the same size as the right partition. Returns the size of",
		  " * the matching. $btoa[i]$ will be the match for vertex $i$ on the right side,",
		  " * or $-1$ if it's not matched.",
		  " * Time: O(VE)",
		  " * Usage: vi btoa(m, -1); dfsMatching(g, btoa);",
		  " * Status: works",
		  " */",
		  "#pragma once",
		  "",
		  "bool find(int j, vector<vi>& g, vi& btoa, vi& vis) {",
		  "	if (btoa[j] == -1) return 1;",
		  "	vis[j] = 1; int di = btoa[j];",
		  "	for (int e : g[di])",
		  "		if (!vis[e] && find(e, g, btoa, vis)) {",
		  "			btoa[e] = di;",
		  "			return 1;",
		  "		}",
		  "	return 0;",
		  "}",
		  "int dfsMatching(vector<vi>& g, vi& btoa) {",
		  "	vi vis;",
		  "	rep(i,0,sz(g)) {",
		  "		vis.assign(sz(btoa), 0);",
		  "		for (int j : g[i])",
		  "			if (find(j, g, btoa, vis)) {",
		  "				btoa[j] = i;",
		  "				break;",
		  "			}",
		  "	}",
		  "	return sz(btoa) - (int)count(all(btoa), -1);",
		  "}",
		  ""
		],
		"description": "DFS Matching"
	  },
	  "Euler Walk": {
		"prefix": "euler walk",
		"body": [
		  "/**",
		  " * Description: Eulerian undirected/directed path/cycle algorithm.",
		  " * Input should be a vector of (dest, global edge index), where",
		  " * for undirected graphs, forward/backward edges have the same index.",
		  " * Returns a list of nodes in the Eulerian path/cycle with src at both start and end, or",
		  " * empty list if no cycle/path exists.",
		  " * To get edge indices back, add .second to s and ret.",
		  " * Time: O(V + E)",
		  " * Status: stress-tested",
		  " */",
		  "#pragma once",
		  "",
		  "vi eulerWalk(vector<vector<pii>>& gr, int nedges, int src=0) {",
		  "	int n = sz(gr);",
		  "	vi D(n), its(n), eu(nedges), ret, s = {src};",
		  "	D[src]++; // to allow Euler paths, not just cycles",
		  "	while (!s.empty()) {",
		  "		int x = s.back(), y, e, &it = its[x], end = sz(gr[x]);",
		  "		if (it == end){ ret.push_back(x); s.pop_back(); continue; }",
		  "		tie(y, e) = gr[x][it++];",
		  "		if (!eu[e]) {",
		  "			D[x]--, D[y]++;",
		  "			eu[e] = 1; s.push_back(y);",
		  "		}}",
		  "	for (int x : D) if (x < 0 || sz(ret) != nedges+1) return {};",
		  "	return {ret.rbegin(), ret.rend()};",
		  "}",
		  ""
		],
		"description": "Euler Walk"
	  },
	  "Topological Sort": {
		"prefix": "topological sort",
		"body": [
		  "/**",
		  " * Description: Topological sorting. Given is an oriented graph.",
		  " * Output is an ordering of vertices, such that there are edges only from left to right.",
		  " * If there are cycles, the returned list will have size smaller than $n$ -- nodes reachable",
		  " * from cycles will not be returned.",
		  " * Time: $O(|V|+|E|)$",
		  " */",
		  "#pragma once",
		  "",
		  "vi topoSort(const vector<vi>& gr) {",
		  "	vi indeg(sz(gr)), ret;",
		  "	for (auto& li : gr) for (int x : li) indeg[x]++;",
		  "	queue<int> q; // use priority queue for lexic. smallest ans.",
		  "	rep(i,0,sz(gr)) if (indeg[i] == 0) q.push(-i);",
		  "	while (!q.empty()) {",
		  "		int i = -q.front(); // top() for priority queue",
		  "		ret.push_back(i);",
		  "		q.pop();",
		  "		for (int x : gr[i])",
		  "			if (--indeg[x] == 0) q.push(-x);",
		  "	}",
		  "	return ret;",
		  "}",
		  ""
		],
		"description": "Topological Sort"
	  },
	  "Strongly Connected Components": {
		"prefix": "strongly connected components SCC",
		"body": [
		  "/**",
		  " * Author: Lukas Polacek",
		  " * Date: 2009-10-28",
		  " * License: CC0",
		  " * Source: Czech graph algorithms book, by Demel. (Tarjan's algorithm)",
		  " * Description: Finds strongly connected components in a",
		  " * directed graph. If vertices $u, v$ belong to the same component,",
		  " * we can reach $u$ from $v$ and vice versa.",
		  " * Time: O(E + V)",
		  " * Status: Bruteforce-tested for N <= 5",
		  " * Usage: scc(graph, [\\&](vi\\& v) { ... }) visits all components",
		  " * in reverse topological order. comp[i] holds the component",
		  " * index of a node (a component only has edges to components with",
		  " * lower index). ncomps will contain the number of components.",
		  " */",
		  "#pragma once",
		  "",
		  "vi val, comp, z, cont;",
		  "int Time, ncomps;",
		  "template<class G, class F> int dfs(int j, G& g, F& f) {",
		  "	int low = val[j] = ++Time, x; z.push_back(j);",
		  "	for (auto e : g[j]) if (comp[e] < 0)",
		  "		low = min(low, val[e] ?: dfs(e,g,f));",
		  "",
		  "	if (low == val[j]) {",
		  "		do {",
		  "			x = z.back(); z.pop_back();",
		  "			comp[x] = ncomps;",
		  "			cont.push_back(x);",
		  "		} while (x != j);",
		  "		f(cont); cont.clear();",
		  "		ncomps++;",
		  "	}",
		  "	return val[j] = low;",
		  "}",
		  "template<class G, class F> void scc(G& g, F f) {",
		  "	int n = sz(g);",
		  "	val.assign(n, 0); comp.assign(n, -1);",
		  "	Time = ncomps = 0;",
		  "	rep(i,0,n) if (comp[i] < 0) dfs(i, g, f);",
		  "}",
		  ""
		],
		"description": "Strongly Connected Components"
	  },
	  "Continued Fractions": {
		"prefix": "continued fractions",
		"body": [
		  "/**",
		  " * Description: Given $N$ and a real number $x \\ge 0$, finds the closest rational approximation $p/q$ with $p, q \\le N$.",
		  " * It will obey $|p/q - x| \\le 1/qN$.",
		  " *",
		  " * For consecutive convergents, $p_{k+1}q_k - q_{k+1}p_k = (-1)^k$.",
		  " * ($p_k/q_k$ alternates between $>x$ and $<x$.)",
		  " * If $x$ is rational, $y$ eventually becomes $\\infty$;",
		  " * if $x$ is the root of a degree $2$ polynomial the $a$'s eventually become cyclic.",
		  " * Time: O(\\log N)",
		  " * Status: stress-tested for n <= 300",
		  " */",
		  "",
		  "typedef double d; // for N ~ 1e7; long double for N ~ 1e9",
		  "pair<ll, ll> approximate(d x, ll N) {",
		  "	ll LP = 0, LQ = 1, P = 1, Q = 0, inf = LLONG_MAX; d y = x;",
		  "	for (;;) {",
		  "		ll lim = min(P ? (N-LP) / P : inf, Q ? (N-LQ) / Q : inf),",
		  "		   a = (ll)floor(y), b = min(a, lim),",
		  "		   NP = b*P + LP, NQ = b*Q + LQ;",
		  "		if (a > b) {",
		  "			// If b > a/2, we have a semi-convergent that gives us a",
		  "			// better approximation; if b = a/2, we *may* have one.",
		  "			// Return {P, Q} here for a more canonical approximation.",
		  "			return (abs(x - (d)NP / (d)NQ) < abs(x - (d)P / (d)Q)) ?",
		  "				make_pair(NP, NQ) : make_pair(P, Q);",
		  "		}",
		  "		if (abs(y = 1/(y - (d)a)) > 3*N) {",
		  "			return {NP, NQ};",
		  "		}",
		  "		LP = P; P = NP;",
		  "		LQ = Q; Q = NQ;",
		  "	}",
		  "}",
		  ""
		],
		"description": "Continued Fractions"
	  },
	  "Euclids Algorithm": {
		"prefix": "euclids",
		"body": [
		  "/**",
		  " * Description: Finds two integers $x$ and $y$, such that $ax+by=\\gcd(a,b)$. If",
		  " * you just need gcd, use the built in \\texttt{\\_\\_gcd} instead.",
		  " * If $a$ and $b$ are coprime, then $x$ is the inverse of $a \\pmod{b}$.",
		  " */",
		  "#pragma once",
		  "",
		  "ll euclid(ll a, ll b, ll &x, ll &y) {",
		  "	if (b) { ll d = euclid(b, a % b, y, x);",
		  "		return y -= a/b * x, d; }",
		  "	return x = 1, y = 0, a;",
		  "}"
		],
		"description": "Euclids Algorithm"
	  },"Sieve of Eratosthenes": {
		"prefix": "sieves of eratosthenes",
		"body": [
		  "/**",
		  " * Description: Prime sieve for generating all primes up to a certain limit. isprime$[i]$ is true iff $i$ is a prime.",
		  " * Status: Tested",
		  " * Time: lim=100'000'000 $\\approx$ 0.8 s. Runs 30\\% faster if only odd indices are stored.",
		  " */",
		  "#pragma once",
		  "",
		  "const int MAX_PR = 5'000'000;",
		  "bitset<MAX_PR> isprime;",
		  "vi eratosthenesSieve(int lim) {",
		  "	isprime.set(); isprime[0] = isprime[1] = 0;",
		  "	for (int i = 4; i < lim; i += 2) isprime[i] = 0;",
		  "	for (int i = 3; i*i < lim; i += 2) if (isprime[i])",
		  "		for (int j = i*i; j < lim; j += i*2) isprime[j] = 0;",
		  "	vi pr;",
		  "	rep(i,2,lim) if (isprime[i]) pr.push_back(i);",
		  "	return pr;",
		  "}",
		  ""
		],
		"description": "Sieve of Eratosthenes"
	  },
	  "Fractional Binary Search": {
		"prefix": "fractional Binary search",
		"body": [
		  "/**",
		  " * Description: Given $f$ and $N$, finds the smallest fraction $p/q \\in [0, 1]$",
		  " * such that $f(p/q)$ is true, and $p, q \\le N$.",
		  " * You may want to throw an exception from $f$ if it finds an exact solution,",
		  " * in which case $N$ can be removed.",
		  " * Usage: fracBS([](Frac f) { return f.p>=3*f.q; }, 10); // {1,3}",
		  " * Time: O(\\log(N))",
		  " * Status: stress-tested for n <= 300",
		  " */",
		  "",
		  "struct Frac { ll p, q; };",
		  "",
		  "template<class F>",
		  "Frac fracBS(F f, ll N) {",
		  "	bool dir = 1, A = 1, B = 1;",
		  "	Frac lo{0, 1}, hi{1, 1}; // Set hi to 1/0 to search (0, N]",
		  "	if (f(lo)) return lo;",
		  "	assert(f(hi));",
		  "	while (A || B) {",
		  "		ll adv = 0, step = 1; // move hi if dir, else lo",
		  "		for (int si = 0; step; (step *= 2) >>= si) {",
		  "			adv += step;",
		  "			Frac mid{lo.p * adv + hi.p, lo.q * adv + hi.q};",
		  "			if (abs(mid.p) > N || mid.q > N || dir == !f(mid)) {",
		  "				adv -= step; si = 2;",
		  "			}",
		  "		}",
		  "		hi.p += lo.p * adv;",
		  "		hi.q += lo.q * adv;",
		  "		dir = !dir;",
		  "		swap(lo, hi);",
		  "		A = B; B = !!adv;",
		  "	}",
		  "	return dir ? hi : lo;",
		  "}",
		  ""
		],
		"description": "Fractional Binary Search"
	  },
	  "modular inverses": {
		"prefix": "mod inverse",
		"body": [
		  "/**",
		  " * Description: Pre-computation of modular inverses. Assumes LIM $\\le$ mod and that mod is a prime.",
		  " * Status: Works",
		  " */",
		  "#pragma once",
		  "",
		  "// const ll mod = 1000000007, LIM = 200000; ///include-line",
		  "ll* inv = new ll[LIM] - 1; inv[1] = 1;",
		  "rep(i,2,LIM) inv[i] = mod - (mod / i) * inv[mod % i] % mod;",
		  ""
		],
		"description": "modular inverses"
	  },
	  "modular log": {
		"prefix": "mod log",
		"body": [
		  "/**",
		  " * Description: Returns the smallest $x > 0$ s.t. $a^x = b \\pmod m$, or",
		  " * $-1$ if no such $x$ exists. modLog(a,1,m) can be used to",
		  " * calculate the order of $a$.",
		  " * Time: $O(\\sqrt m)$",
		  " * Status: tested for all 0 <= a,x < 500 and 0 < m < 500.",
		  " *",
		  " * Details: This algorithm uses the baby-step giant-step method to",
		  " * find (i,j) such that a^(n * i) = b * a^j (mod m), where n > sqrt(m)",
		  " * and 0 < i, j <= n. If a and m are coprime then a^j has a modular",
		  " * inverse, which means that a^(i * n - j) = b (mod m$).",
		  " *",
		  " * However this particular implementation of baby-step giant-step works even",
		  " * without assuming a and m are coprime, using the following idea:",
		  " *",
		  " * Assume p^x is a prime divisor of m. Then we have 3 cases",
		  " *	 1. b is divisible by p^x",
		  " *	 2. b is divisible only by some p^y, 0<y<x",
		  " *	 3. b is not divisible by p",
		  " * The important thing to note is that in case 2, modLog(a,b,m) (if",
		  " * it exists) cannot be > sqrt(m), (technically it cannot be >= log2(m)).",
		  " * So once all exponenents of a that are <= sqrt(m) has been checked, you",
		  " * cannot have case 2. Case 2 is the only tricky case.",
		  " *",
		  " * So the modification allowing for non-coprime input invloves checking all",
		  " * exponents of a that are <= n, and then handling the non-tricky cases by",
		  " * a simple gcd(a^n,m) == gcd(b,m) check.",
		  " */",
		  "#pragma once",
		  "",
		  "ll modLog(ll a, ll b, ll m) {",
		  "	ll n = (ll) sqrt(m) + 1, e = 1, f = 1, j = 1;",
		  "	unordered_map<ll, ll> A;",
		  "	while (j <= n && (e = f = e * a % m) != b % m)",
		  "		A[e * b % m] = j++;",
		  "	if (e == b % m) return j;",
		  "	if (__gcd(m, e) == __gcd(m, b)) ",
		  "		rep(i,2,n+2) if (A.count(e = e * f % m))",
		  "			return n * i - A[e];",
		  "	return -1;",
		  "}",
		  ""
		],
		"description": "modular log"
	  },
	  "Modulo Multiplication": {
		"prefix": "mod multiplication",
		"body": [
		  "/**",
		  " * Description: Calculate $a\\cdot b\\bmod c$ (or $a^b \\bmod c$) for $0 \\le a, b \\le c \\le 7.2\\cdot 10^{18}$.",
		  " * Time: O(1) for \\texttt{modmul}, O(\\log b) for \\texttt{modpow}",
		  " * Status: stress-tested, proven correct",
		  " * Details:",
		  " * This runs ~2x faster than the naive (__int128_t)a * b % M.",
		  " * A proof of correctness is in doc/modmul-proof.tex. An earlier version of the proof,",
		  " * from when the code used a * b / (long double)M, is in doc/modmul-proof.md.",
		  " */",
		  "#pragma once",
		  "",
		  "typedef unsigned long long ull;",
		  "ull modmul(ull a, ull b, ull M) {",
		  "	ll ret = a * b - M * ull(1.L / M * a * b);",
		  "	return ret + M * (ret < 0) - M * (ret >= (ll)M);",
		  "}",
		  "ull modpow(ull b, ull e, ull mod) {",
		  "	ull ans = 1;",
		  "	for (; e; b = modmul(b, b, mod), e /= 2)",
		  "		if (e & 1) ans = modmul(ans, b, mod);",
		  "	return ans;",
		  "}",
		  ""
		],
		"description": "Modulo Multiplication"
	  },
	  "Modulo Power": {
		"prefix": "mod pow",
		"body": [
		  "/**",
		  " * Description:",
		  " * Status: tested",
		  " */",
		  "#pragma once",
		  "",
		  "const ll mod = 1000000007; // faster if const",
		  "",
		  "ll modpow(ll b, ll e) {",
		  "	ll ans = 1;",
		  "	for (; e; b = b * b % mod, e /= 2)",
		  "		if (e & 1) ans = ans * b % mod;",
		  "	return ans;",
		  "}",
		  ""
		],
		"description": "Modulo Power"
	  },
	  "Modulo Sum": {
		"prefix": "mod sum",
		"body": [
		  "/**",
		  " * Description: Sums of mod'ed arithmetic progressions.",
		  " *",
		  " * \\texttt{modsum(to, c, k, m)} = $\\sum_{i=0}^{\\mathrm{to}-1}{(ki+c) \\% m}$.",
		  " * \\texttt{divsum} is similar but for floored division.",
		  " * Status: Tested for |k|,|c|,to,m <= 50, and on \"aladin\" on kattis.",
		  " * Time: $\\log(m)$, with a large constant.",
		  " */",
		  "#pragma once",
		  "",
		  "typedef unsigned long long ull;",
		  "ull sumsq(ull to) { return to / 2 * ((to-1) | 1); }",
		  "/// ^ written in a weird way to deal with overflows correctly",
		  "",
		  "ull divsum(ull to, ull c, ull k, ull m) {",
		  "	ull res = k / m * sumsq(to) + c / m * to;",
		  "	k %= m; c %= m;",
		  "	if (!k) return res;",
		  "	ull to2 = (to * k + c) / m;",
		  "	return res + (to - 1) * to2 - divsum(to2, m-1 - c, m, k);",
		  "}",
		  "",
		  "ll modsum(ull to, ll c, ll k, ll m) {",
		  "	c = ((c % m) + m) % m;",
		  "	k = ((k % m) + m) % m;",
		  "	return to * c + k * sumsq(to) - m * divsum(to, c, k, m);",
		  "}",
		  ""
		],
		"description": "Modulo Sum"
	  },
	  "Modular Arithmetic ": {
		"prefix": "mod Arithmetic",
		"body": [
		  "/**",
		  " * Description: Operators for modular arithmetic. You need to set {\\tt mod} to",
		  " * some number first and then you can use the structure.",
		  " */",
		  "#pragma once",
		  "",
		  "ll euclid(ll a, ll b, ll &x, ll &y) {",
		  "	if (b) { ll d = euclid(b, a % b, y, x);",
		  "		return y -= a/b * x, d; }",
		  "	return x = 1, y = 0, a;",
		  "}",
		  "",
		  "",
		  "const ll mod = 17; // change to something else",
		  "struct Mod {",
		  "	ll x;",
		  "	Mod(ll xx) : x(xx) {}",
		  "	Mod operator+(Mod b) { return Mod((x + b.x) % mod); }",
		  "	Mod operator-(Mod b) { return Mod((x - b.x + mod) % mod); }",
		  "	Mod operator*(Mod b) { return Mod((x * b.x) % mod); }",
		  "	Mod operator/(Mod b) { return *this * invert(b); }",
		  "	Mod invert(Mod a) {",
		  "		ll x, y, g = euclid(a.x, mod, x, y);",
		  "		assert(g == 1); return Mod((x + mod) % mod);",
		  "	}",
		  "	Mod operator^(ll e) {",
		  "		if (!e) return Mod(1);",
		  "		Mod r = *this ^ (e / 2); r = r * r;",
		  "		return e&1 ? *this * r : r;",
		  "	}",
		  "};",
		  ""
		],
		"description": "Modular Arithmetic "
	  },
	  "Fast fourier Transform": {
		"prefix": "fft",
		"body": [
		  "/**",
		  " * Description: fft(a) computes $\\hat f(k) = \\sum_x a[x] \\exp(2\\pi i \\cdot k x / N)$ for all $k$. N must be a power of 2.",
		  "   Useful for convolution:",
		  "   \\texttt{conv(a, b) = c}, where $c[x] = \\sum a[i]b[x-i]$.",
		  "   For convolution of complex numbers or more than two vectors: FFT, multiply",
		  "   pointwise, divide by n, reverse(start+1, end), FFT back.",
		  "   Rounding is safe if $(\\sum a_i^2 + \\sum b_i^2)\\log_2{N} < 9\\cdot10^{14}$",
		  "   (in practice $10^{16}$; higher for random inputs).",
		  "   Otherwise, use NTT/FFTMod.",
		  " * Time: O(N \\log N) with $N = |A|+|B|$ ($\\tilde 1s$ for $N=2^{22}$)",
		  " * Status: somewhat tested",
		  " * Details: An in-depth examination of precision for both FFT and FFTMod can be found",
		  " * here (https://github.com/simonlindholm/fft-precision/blob/master/fft-precision.md)",
		  " */",
		  "#pragma once",
		  "",
		  "typedef complex<double> C;",
		  "typedef vector<double> vd;",
		  "void fft(vector<C>& a) {",
		  "	int n = sz(a), L = 31 - __builtin_clz(n);",
		  "	static vector<complex<long double>> R(2, 1);",
		  "	static vector<C> rt(2, 1);  // (^ 10% faster if double)",
		  "	for (static int k = 2; k < n; k *= 2) {",
		  "		R.resize(n); rt.resize(n);",
		  "		auto x = polar(1.0L, acos(-1.0L) / k);",
		  "		rep(i,k,2*k) rt[i] = R[i] = i&1 ? R[i/2] * x : R[i/2];",
		  "	}",
		  "	vi rev(n);",
		  "	rep(i,0,n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
		  "	rep(i,0,n) if (i < rev[i]) swap(a[i], a[rev[i]]);",
		  "	for (int k = 1; k < n; k *= 2)",
		  "		for (int i = 0; i < n; i += 2 * k) rep(j,0,k) {",
		  "			// C z = rt[j+k] * a[i+j+k]; // (25% faster if hand-rolled)  /// include-line",
		  "			auto x = (double *)&rt[j+k], y = (double *)&a[i+j+k];        /// exclude-line",
		  "			C z(x[0]*y[0] - x[1]*y[1], x[0]*y[1] + x[1]*y[0]);           /// exclude-line",
		  "			a[i + j + k] = a[i + j] - z;",
		  "			a[i + j] += z;",
		  "		}",
		  "}",
		  "vd conv(const vd& a, const vd& b) {",
		  "	if (a.empty() || b.empty()) return {};",
		  "	vd res(sz(a) + sz(b) - 1);",
		  "	int L = 32 - __builtin_clz(sz(res)), n = 1 << L;",
		  "	vector<C> in(n), out(n);",
		  "	copy(all(a), begin(in));",
		  "	rep(i,0,sz(b)) in[i].imag(b[i]);",
		  "	fft(in);",
		  "	for (C& x : in) x *= x;",
		  "	rep(i,0,n) out[i] = in[-i & (n - 1)] - conj(in[i]);",
		  "	fft(out);",
		  "	rep(i,0,sz(res)) res[i] = imag(out[i]) / (4 * n);",
		  "	return res;",
		  "}",
		  ""
		],
		"description": "Fast fourier Transform"
	  },
	  "Hill Climbing": {
		"prefix": "hill climbing",
		"body": [
		  "/**",
		  " * Description: Poor man's optimization for unimodal functions.",
		  " * Status: used with great success",
		  " */",
		  "#pragma once",
		  "",
		  "typedef array<double, 2> P;",
		  "",
		  "template<class F> pair<double, P> hillClimb(P start, F f) {",
		  "	pair<double, P> cur(f(start), start);",
		  "	for (double jmp = 1e9; jmp > 1e-20; jmp /= 2) {",
		  "		rep(j,0,100) rep(dx,-1,2) rep(dy,-1,2) {",
		  "			P p = cur.second;",
		  "			p[0] += dx*jmp;",
		  "			p[1] += dy*jmp;",
		  "			cur = min(cur, make_pair(f(p), p));",
		  "		}",
		  "	}",
		  "	return cur;",
		  "}",
		  ""
		],
		"description": "Hill Climbing"
	  },
	  "Determinant": {
		"prefix": "determinant",
		"body": [
		  "/**",
		  " * Description: Calculates determinant using modular arithmetics.",
		  " * Modulos can also be removed to get a pure-integer version.",
		  " * Status: bruteforce-tested for N <= 3, mod <= 7",
		  " * Time: $O(N^3)$",
		  " */",
		  "#pragma once",
		  "",
		  "const ll mod = 12345;",
		  "ll det(vector<vector<ll>>& a) {",
		  "	int n = sz(a); ll ans = 1;",
		  "	rep(i,0,n) {",
		  "		rep(j,i+1,n) {",
		  "			while (a[j][i] != 0) { // gcd step",
		  "				ll t = a[i][i] / a[j][i];",
		  "				if (t) rep(k,i,n)",
		  "					a[i][k] = (a[i][k] - a[j][k] * t) % mod;",
		  "				swap(a[i], a[j]);",
		  "				ans *= -1;",
		  "			}",
		  "		}",
		  "		ans = ans * a[i][i] % mod;",
		  "		if (!ans) return 0;",
		  "	}",
		  "	return (ans + mod) % mod;",
		  "}",
		  ""
		],
		"description": "Determinant"
	  },
	  "KMP": {
		"prefix": "kmp",
		"body": [
		  "/**",
		  " * Description: pi[x] computes the length of the longest prefix of s that ends at x, other than s[0...x] itself (abacaba -> 0010123).",
		  " * Can be used to find all occurrences of a string.",
		  " * Time: O(n)",
		  " * Status: Tested on Kattis, stringmatching",
		  " */",
		  "#pragma once",
		  "",
		  "vi pi(const string& s) {",
		  "	vi p(sz(s));",
		  "	rep(i,1,sz(s)) {",
		  "		int g = p[i-1];",
		  "		while (g && s[i] != s[g]) g = p[g-1];",
		  "		p[i] = g + (s[i] == s[g]);",
		  "	}",
		  "	return p;",
		  "}",
		  "",
		  "vi match(const string& s, const string& pat) {",
		  "	vi p = pi(pat + '\\0' + s), res;",
		  "	rep(i,sz(p)-sz(s),sz(p))",
		  "		if (p[i] == sz(pat)) res.push_back(i - 2 * sz(pat));",
		  "	return res;",
		  "}",
		  ""
		],
		"description": "KMP"
	  },
	  "Suffix Array": {
		"prefix": "suffix array string",
		"body": [
		  "/**",
		  " * Source: Suffix array - a powerful tool for dealing with strings",
		  " * (Chinese IOI National team training paper, 2009)",
		  " * Description: Builds suffix array for a string.",
		  " * \\texttt{sa[i]} is the starting index of the suffix which",
		  " * is $i$'th in the sorted suffix array.",
		  " * The returned vector is of size $n+1$, and \\texttt{sa[0] = n}.",
		  " * The \\texttt{lcp} array contains longest common prefixes for",
		  " * neighbouring strings in the suffix array:",
		  " * \\texttt{lcp[i] = lcp(sa[i], sa[i-1])}, \\texttt{lcp[0] = 0}.",
		  " * The input string must not contain any zero bytes.",
		  " * Time: O(n \\log n)",
		  " * Status: stress-tested",
		  " */",
		  "#pragma once",
		  "",
		  "struct SuffixArray {",
		  "	vi sa, lcp;",
		  "	SuffixArray(string& s, int lim=256) { // or basic_string<int>",
		  "		int n = sz(s) + 1, k = 0, a, b;",
		  "		vi x(all(s)+1), y(n), ws(max(n, lim)), rank(n);",
		  "		sa = lcp = y, iota(all(sa), 0);",
		  "		for (int j = 0, p = 0; p < n; j = max(1, j * 2), lim = p) {",
		  "			p = j, iota(all(y), n - j);",
		  "			rep(i,0,n) if (sa[i] >= j) y[p++] = sa[i] - j;",
		  "			fill(all(ws), 0);",
		  "			rep(i,0,n) ws[x[i]]++;",
		  "			rep(i,1,lim) ws[i] += ws[i - 1];",
		  "			for (int i = n; i--;) sa[--ws[x[y[i]]]] = y[i];",
		  "			swap(x, y), p = 1, x[sa[0]] = 0;",
		  "			rep(i,1,n) a = sa[i - 1], b = sa[i], x[b] =",
		  "				(y[a] == y[b] && y[a + j] == y[b + j]) ? p - 1 : p++;",
		  "		}",
		  "		rep(i,1,n) rank[sa[i]] = i;",
		  "		for (int i = 0, j; i < n - 1; lcp[rank[i++]] = k)",
		  "			for (k && k--, j = sa[rank[i] - 1];",
		  "					s[i + k] == s[j + k]; k++);",
		  "	}",
		  "};",
		  ""
		],
		"description": "Suffix Array"
	  },
	  "Suffix Tree ": {
		"prefix": "suffix tree string",
		"body": [
		  "/**",
		  " * Description: Ukkonen's algorithm for online suffix tree construction.",
		  " *  Each node contains indices [l, r) into the string, and a list of child nodes.",
		  " *  Suffixes are given by traversals of this tree, joining [l, r) substrings.",
		  " *  The root is 0 (has l = -1, r = 0), non-existent children are -1.",
		  " *  To get a complete tree, append a dummy symbol -- otherwise it may contain",
		  " *  an incomplete path (still useful for substring matching, though).",
		  " * Time: $O(26N)$",
		  " * Status: stress-tested a bit",
		  " */",
		  "#pragma once",
		  "",
		  "struct SuffixTree {",
		  "	enum { N = 200010, ALPHA = 26 }; // N ~ 2*maxlen+10",
		  "	int toi(char c) { return c - 'a'; }",
		  "	string a; // v = cur node, q = cur position",
		  "	int t[N][ALPHA],l[N],r[N],p[N],s[N],v=0,q=0,m=2;",
		  "",
		  "	void ukkadd(int i, int c) { suff:",
		  "		if (r[v]<=q) {",
		  "			if (t[v][c]==-1) { t[v][c]=m;  l[m]=i;",
		  "				p[m++]=v; v=s[v]; q=r[v];  goto suff; }",
		  "			v=t[v][c]; q=l[v];",
		  "		}",
		  "		if (q==-1 || c==toi(a[q])) q++; else {",
		  "			l[m+1]=i;  p[m+1]=m;  l[m]=l[v];  r[m]=q;",
		  "			p[m]=p[v];  t[m][c]=m+1;  t[m][toi(a[q])]=v;",
		  "			l[v]=q;  p[v]=m;  t[p[m]][toi(a[l[m]])]=m;",
		  "			v=s[p[m]];  q=l[m];",
		  "			while (q<r[m]) { v=t[v][toi(a[q])];  q+=r[v]-l[v]; }",
		  "			if (q==r[m])  s[m]=v;  else s[m]=m+2;",
		  "			q=r[v]-(q-r[m]);  m+=2;  goto suff;",
		  "		}",
		  "	}",
		  "",
		  "	SuffixTree(string a) : a(a) {",
		  "		fill(r,r+N,sz(a));",
		  "		memset(s, 0, sizeof s);",
		  "		memset(t, -1, sizeof t);",
		  "		fill(t[1],t[1]+ALPHA,0);",
		  "		s[0] = 1; l[0] = l[1] = -1; r[0] = r[1] = p[0] = p[1] = 0;",
		  "		rep(i,0,sz(a)) ukkadd(i, toi(a[i]));",
		  "	}",
		  "",
		  "	// example: find longest common substring (uses ALPHA = 28)",
		  "	pii best;",
		  "	int lcs(int node, int i1, int i2, int olen) {",
		  "		if (l[node] <= i1 && i1 < r[node]) return 1;",
		  "		if (l[node] <= i2 && i2 < r[node]) return 2;",
		  "		int mask = 0, len = node ? olen + (r[node] - l[node]) : 0;",
		  "		rep(c,0,ALPHA) if (t[node][c] != -1)",
		  "			mask |= lcs(t[node][c], i1, i2, len);",
		  "		if (mask == 3)",
		  "			best = max(best, {len, r[node] - len});",
		  "		return mask;",
		  "	}",
		  "	static pii LCS(string s, string t) {",
		  "		SuffixTree st(s + (char)('z' + 1) + t + (char)('z' + 2));",
		  "		st.lcs(0, sz(s), sz(s) + 1 + sz(t), 0);",
		  "		return st.best;",
		  "	}",
		  "};",
		  ""
		],
		"description": "Suffix Tree "
	  },
	  "Fast Modulos": {
		"prefix": "fast mod",
		"body": [
		  "/**",
		  " * Description: Compute $a \\% b$ about 5 times faster than usual, where $b$ is constant but not known at compile time.",
		  " * Returns a value congruent to $a \\pmod b$ in the range $[0, 2b)$.",
		  " * Status: proven correct, stress-tested",
		  " * Measured as having 4 times lower latency, and 8 times higher throughput, see stress-test.",
		  " * Details:",
		  " * More precisely, it can be proven that the result equals 0 only if $a = 0$,",
		  " * and otherwise lies in $[1, (1 + a/2^64) * b)$.",
		  " */",
		  "#pragma once",
		  "",
		  "typedef unsigned long long ull;",
		  "struct FastMod {",
		  "	ull b, m;",
		  "	FastMod(ull b) : b(b), m(-1ULL / b) {}",
		  "	ull reduce(ull a) { // a % b + (0 or b)",
		  "		return a - (ull)((__uint128_t(m) * a) >> 64) * b;",
		  "	}",
		  "};",
		  ""
		],
		"description": "Fast Modulos"
	  },
	  "Graph": {
		"prefix": "graph",
		"body": [
		  "class Graph",
		  "{",
		  "  private:",
		  "	set<int> Vertices;",
		  "	set<pair<int , int>> Edges;",
		  "",
		  "	map<pair<int, int>, int> Weight_of_Edges;",
		  "	map<int, set<int>> AdjList_of_Vertices;",
		  "",
		  "",
		  "  public:",
		  "	int Nvertices, Nedges;",
		  "	bool isDirected;",
		  "",
		  "	set<int> vertices()",
		  "	{",
		  "		return Vertices;",
		  "	}",
		  "",
		  "	struct attribute",
		  "	{",
		  "		bool visited = false;",
		  "		int distance = INT_MAX;",
		  "		int parent = 0;",
		  "	};",
		  "	vector<attribute> Attributes;",
		  "",
		  "	Graph ( int Nvertices, int Nedges, bool isDirected = false )",
		  "	{",
		  "		this->Nvertices = Nvertices;",
		  "		this->Nedges = Nedges;",
		  "		this->isDirected = isDirected;",
		  "",
		  "		set<int> s = {};",
		  "		attribute atb;",
		  "",
		  "		for ( int i = 1; i <= Nvertices; i++ )",
		  "		{",
		  "			AdjList_of_Vertices.insert ( make_pair ( i, s ) );",
		  "			Attributes.push_back ( atb );",
		  "		}",
		  "	}",
		  "",
		  "	set<int> adjList ( int vertex )",
		  "	// returns the adjacency list (a set) of a vertex.",
		  "	{",
		  "		return AdjList_of_Vertices[vertex];",
		  "	}",
		  "",
		  "	int get_weight ( int u, int v )",
		  "	// returns the weight of th edge {u, v}",
		  "	{",
		  "		return Weight_of_Edges[make_pair ( u, v )];",
		  "	}",
		  "",
		  "	int get_weight ( pair<int, int> edge )",
		  "	{",
		  "		return Weight_of_Edges[edge];",
		  "	}",
		  "",
		  "	void insert_edge ( int u, int v, int weight = 1 )",
		  "	{",
		  "		new_edge ( u, v, make_pair ( u, v ), weight );",
		  "",
		  "		if ( !isDirected )",
		  "		{",
		  "			new_edge ( v, u, make_pair ( v, u ), weight );",
		  "		}",
		  "",
		  "	}",
		  "",
		  "	void insert_edge ( pair<int, int> edge, int weight = 1 )",
		  "	{",
		  "		insert_edge ( edge.first, edge.second, weight );",
		  "	}",
		  "",
		  "	void new_edge ( int u, int v, pair<int, int> edge, int weight )",
		  "	{",
		  "		AdjList_of_Vertices[u].insert ( v );",
		  "		Edges.insert ( edge );",
		  "		Weight_of_Edges.insert ( make_pair ( edge, weight ) );",
		  "	}",
		  "",
		  "	bool is_visited ( int u )",
		  "	{",
		  "		return Attributes[u].visited;",
		  "	}",
		  "",
		  "	bool get_distance ( int u )",
		  "	{",
		  "		return Attributes[u]. distance;",
		  "	}",
		  "",
		  "	bool is_edge ( int u, int v )",
		  "	{",
		  "		if ( Edges.count ( make_pair ( u, v ) ) == 0 ) return false;",
		  "",
		  "		return true;",
		  "	}",
		  "",
		  "	int get_parent ( int u )",
		  "	{",
		  "		return Attributes[u].parent;",
		  "	}",
		  "",
		  "	void visit ( int u )",
		  "	{",
		  "		Attributes[u].visited = true;",
		  "	}",
		  "",
		  "	void set_distance ( int node, int new_distance )",
		  "	{",
		  "		Attributes[node].distance = new_distance;",
		  "	}",
		  "",
		  "	void set_parent ( int child, int parent )",
		  "	{",
		  "		Attributes[child].parent = parent;",
		  "	}",
		  "};",
		  "",
		  "//__________________________________________________________________________________//",
		  "//----------------------------------------------------------------------------------//",
		  "",
		  "/*",
		  "The following BFS function is for the purpose of checking",
		  "that the Graph class and its members work correctly.",
		  "*/",
		  "",
		  "void BFS ( Graph &g, int source )",
		  "{",
		  "	for ( auto u : g.vertices() )",
		  "	{",
		  "		g.set_distance ( u, INT_MAX );",
		  "		g.set_parent ( u, 0 );",
		  "	}",
		  "",
		  "	queue<int> q;",
		  "	g.set_distance ( source, 0 );",
		  "	q.push ( source );",
		  "",
		  "	while ( q.empty() == false )",
		  "	{",
		  "		auto u = q.front();",
		  "		q.pop();",
		  "",
		  "		for ( auto v : g.adjList ( u ) )",
		  "		{",
		  "			if ( g.is_visited ( v ) == false )",
		  "			{",
		  "				g.visit ( v );",
		  "				g.set_parent ( v, u );",
		  "				q.push ( v );",
		  "			}",
		  "",
		  "		}",
		  "	}",
		  "",
		  "",
		  "}",
		  "",
		  "//-----------------------------------------------------------------------------------//",
		  "//-----------------------------------------------------------------------------------//",
		  "",
		  "/* Driver program to check the BFS function and the Graph class. */",
		  "",
		  "int main()",
		  "{",
		  "	int n, e;",
		  "	cin >> n >> e;",
		  "	Graph g ( n, e );",
		  "",
		  "	while ( e-- )",
		  "	{",
		  "		int u, v;",
		  "		cin >> u >> v;",
		  "		g.insert_edge ( u, v );",
		  "	}",
		  "",
		  "	BFS ( g, 1 );",
		  "",
		  "	for ( int i = 1; i <= n; i++ )",
		  "	{",
		  "		cout << i << \" : \" << g.get_parent ( i ) << endl;",
		  "	}",
		  "",
		  "	return 0;",
		  "}"
		],
		"description": "Graph"
	  }




	
}